using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
using Trickle.Common.DataSources;
using Trickle.Common.Dimensions;
using Trickle.Common.Domain;
using Trickle.Common.Infrastructure;
using Trickle.Common.Messaging;
using Trickle.ContainerSecurity.DataSources.Dimensions;
using Trickle.ContainerSecurity.DataSources.Services;
using Trickle.ContainerSecurity.Domain.Events;
using Trickle.ContainerSecurity.Domain.Models;

namespace Trickle.ContainerSecurity.DataSources.Events.CSharp
{
    /// <summary>
    /// Detects container vulnerabilities from StackRox API
    /// </summary>
    public class StackRoxVulnerabilityDetector : BaseDataSource, IEventSource
    {
        private readonly ILogger<StackRoxVulnerabilityDetector> _logger;
        private readonly StackRoxClient _stackRoxClient;
        private readonly ISecurityEventPublisher _eventPublisher;
        private readonly IDimension<ClusterInfo> _clusterDimension;
        private readonly IDimension<CveAllowlistEntry> _cveAllowlist;
        private readonly RegionalContext _regionalContext;
        
        public StackRoxVulnerabilityDetector(
            ILogger<StackRoxVulnerabilityDetector> logger,
            StackRoxClient stackRoxClient,
            ISecurityEventPublisher eventPublisher,
            IDimension<ClusterInfo> clusterDimension,
            IDimension<CveAllowlistEntry> cveAllowlist,
            RegionalContext regionalContext)
        {
            _logger = logger;
            _stackRoxClient = stackRoxClient;
            _eventPublisher = eventPublisher;
            _clusterDimension = clusterDimension;
            _cveAllowlist = cveAllowlist;
            _regionalContext = regionalContext;
        }
        
        [Function("StackRoxVulnerabilityDetector")]
        public async Task Run([TimerTrigger("0 */30 * * * *")] FunctionContext context)
        {
            _logger.LogInformation("StackRox vulnerability scan starting at: {Time}", DateTime.UtcNow);
            
            try
            {
                // Run the vulnerability detection
                await CollectEventsAsync();
                
                _logger.LogInformation("StackRox vulnerability scan completed successfully");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in StackRox vulnerability scan");
                throw;
            }
        }
        
        /// <summary>
        /// Collects vulnerability events from StackRox
        /// </summary>
        public async Task CollectEventsAsync(CancellationToken cancellationToken = default)
        {
            var stopwatch = Stopwatch.StartNew();
            var totalEvents = 0;
            
            try
            {
                // Get clusters from dimension cache
                var clusters = await _clusterDimension.GetAllAsync();
                
                // Get allowlist entries
                var allowlistEntries = await _cveAllowlist.GetAllAsync();
                
                _logger.LogInformation("Processing {ClusterCount} clusters with StackRox integration", 
                    clusters.Count);
                
                foreach (var cluster in clusters)
                {
                    // Skip clusters that don't have StackRox integration
                    if (!cluster.StackRoxIntegrated)
                    {
                        continue;
                    }
                    
                    // Skip clusters not in regional scope (if region filtering is enabled)
                    if (_regionalContext.IsRegionalInstance && 
                        !IsClusterInRegionalScope(cluster))
                    {
                        _logger.LogDebug("Skipping cluster {ClusterName} as it's not in regional scope for {Region}",
                            cluster.Name, _regionalContext.Region);
                        continue;
                    }
                    
                    // Process this cluster
                    var eventsForCluster = await ProcessClusterAsync(cluster, allowlistEntries, cancellationToken);
                    totalEvents += eventsForCluster;
                }
                
                stopwatch.Stop();
                _logger.LogInformation("StackRox vulnerability scan completed in {ElapsedMs}ms, published {EventCount} events",
                    stopwatch.ElapsedMilliseconds, totalEvents);
                
                // Track the collection
                TrackRefresh(totalEvents, stopwatch.Elapsed);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error collecting StackRox vulnerabilities");
                throw;
            }
        }
        
        /// <summary>
        /// Process vulnerabilities for a single cluster
        /// </summary>
        private async Task<int> ProcessClusterAsync(
            ClusterInfo cluster, 
            IReadOnlyList<CveAllowlistEntry> allowlistEntries,
            CancellationToken cancellationToken)
        {
            try
            {
                _logger.LogInformation("Scanning cluster {ClusterName} for vulnerabilities", cluster.Name);
                
                // Get containers with vulnerabilities from StackRox
                var containers = await _stackRoxClient.GetContainersWithVulnerabilitiesAsync(
                    cluster.ClusterId, null, cancellationToken);
                
                _logger.LogInformation("Found {ContainerCount} containers with vulnerabilities in cluster {ClusterName}",
                    containers.Count, cluster.Name);
                
                int eventCount = 0;
                
                // Process each container
                foreach (var container in containers)
                {
                    // Process vulnerabilities in this container
                    foreach (var vulnerability in container.Vulnerabilities)
                    {
                        // Skip allowlisted vulnerabilities
                        if (IsAllowlisted(vulnerability, container, allowlistEntries))
                        {
                            _logger.LogDebug("Skipping allowlisted vulnerability {CveId} in container {ContainerName}",
                                vulnerability.CveId, container.Name);
                            continue;
                        }
                        
                        // Create and publish vulnerability event
                        await PublishVulnerabilityEventAsync(vulnerability, container, cluster);
                        eventCount++;
                    }
                }
                
                _logger.LogInformation("Published {EventCount} vulnerability events for cluster {ClusterName}",
                    eventCount, cluster.Name);
                
                return eventCount;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing vulnerabilities for cluster {ClusterName}",
                    cluster.Name);
                throw;
            }
        }
        
        /// <summary>
        /// Create and publish vulnerability event
        /// </summary>
        private async Task PublishVulnerabilityEventAsync(
            Vulnerability vulnerability, 
            Container container, 
            ClusterInfo cluster)
        {
            try
            {
                // Map to severity
                var severity = MapSeverity(vulnerability.Severity);
                
                // Determine tenant ID from cluster
                var tenantId = cluster.GetTenantId();
                
                // Create the event
                var vulnerabilityEvent = new ContainerVulnerabilityEvent
                {
                    CveId = vulnerability.CveId,
                    VulnerabilityName = vulnerability.Name,
                    CvssScore = vulnerability.CvssScore,
                    Severity = severity,
                    ResourceId = cluster.ResourceId ?? $"stackrox-cluster:{cluster.ClusterId}",
                    OwnerId = tenantId,
                    ClusterId = cluster.ClusterId,
                    ImageName = container.ImageName,
                    ImageTag = container.ImageTag,
                    ContainerName = container.Name,
                    PodName = container.PodName,
                    Namespace = container.Namespace,
                    NodeName = container.NodeName,
                    Description = vulnerability.Description,
                    AffectedPackage = vulnerability.AffectedPackage,
                    InstalledVersion = vulnerability.InstalledVersion,
                    FixedVersion = vulnerability.FixedVersion,
                    InfoLink = vulnerability.InfoLink,
                    IsFixable = vulnerability.IsFixable,
                    FirstDetectedAt = DateTime.UtcNow,
                    RemediationGuidance = vulnerability.RemediationGuidance
                };
                
                // Add cluster info to metadata
                vulnerabilityEvent.Metadata["ClusterName"] = cluster.Name;
                vulnerabilityEvent.Metadata["KubernetesVersion"] = cluster.KubernetesVersion;
                
                if (cluster.IsAksCluster)
                {
                    vulnerabilityEvent.Metadata["AksCluster"] = "true";
                    vulnerabilityEvent.Metadata["AksResourceGroup"] = cluster.ResourceGroupName;
                    vulnerabilityEvent.Metadata["AksRegion"] = cluster.Location;
                }
                
                // Publish the event
                await _eventPublisher.PublishEventAsync(vulnerabilityEvent);
                
                _logger.LogDebug("Published vulnerability event for {CveId} in {ContainerName}",
                    vulnerability.CveId, container.Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error publishing vulnerability event for {CveId} in {ContainerName}",
                    vulnerability.CveId, container.Name);
                throw;
            }
        }
        
        /// <summary>
        /// Check if a vulnerability is allowlisted
        /// </summary>
        private bool IsAllowlisted(
            Vulnerability vulnerability, 
            Container container, 
            IReadOnlyList<CveAllowlistEntry> allowlistEntries)
        {
            foreach (var entry in allowlistEntries)
            {
                if (entry.AppliesTo(
                    vulnerability.CveId, 
                    vulnerability.AffectedPackage, 
                    container.ClusterId, 
                    container.Namespace))
                {
                    return true;
                }
            }
            
            return false;
        }
        
        /// <summary>
        /// Map StackRox severity to Trickle severity
        /// </summary>
        private SecuritySeverity MapSeverity(VulnerabilitySeverity severity)
        {
            return severity switch
            {
                VulnerabilitySeverity.Critical => SecuritySeverity.Critical,
                VulnerabilitySeverity.High => SecuritySeverity.High,
                VulnerabilitySeverity.Medium => SecuritySeverity.Medium,
                VulnerabilitySeverity.Low => SecuritySeverity.Low,
                _ => SecuritySeverity.Low
            };
        }
        
        /// <summary>
        /// Check if cluster is in the regional scope
        /// </summary>
        private bool IsClusterInRegionalScope(ClusterInfo cluster)
        {
            // If regional context is not enabled, all clusters are in scope
            if (!_regionalContext.IsRegionalInstance)
                return true;
                
            // If we have a direct match on location, it's in scope
            if (!string.IsNullOrEmpty(cluster.Location) && 
                cluster.Location.Equals(_regionalContext.Region, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
            
            // Check by subscription ID
            if (!string.IsNullOrEmpty(cluster.SubscriptionId) &&
                _regionalContext.SupportedSubscriptions.Contains(cluster.SubscriptionId))
            {
                return true;
            }
            
            // Not in scope
            return false;
        }
    }
}
