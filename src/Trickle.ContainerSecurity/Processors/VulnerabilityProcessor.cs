using System;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Messaging.ServiceBus;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
using Trickle.Common.Dimensions;
using Trickle.Common.Domain;
using Trickle.Common.Messaging;
using Trickle.Common.State;
using Trickle.ContainerSecurity.DataSources.Dimensions;
using Trickle.ContainerSecurity.Domain.Events;

namespace Trickle.ContainerSecurity.Processors.CSharp
{
    /// <summary>
    /// Processes container vulnerability events
    /// </summary>
    public class VulnerabilityProcessor
    {
        private readonly ILogger<VulnerabilityProcessor> _logger;
        private readonly ISecurityEventPublisher _eventPublisher;
        private readonly IDimension<ClusterInfo> _clusterDimension;
        private readonly IDimension<VulnerabilityThreshold> _thresholdDimension;
        private readonly ContainerVulnerabilityRepository _vulnerabilityRepository;
        
        public VulnerabilityProcessor(
            ILogger<VulnerabilityProcessor> logger,
            ISecurityEventPublisher eventPublisher,
            IDimension<ClusterInfo> clusterDimension,
            IDimension<VulnerabilityThreshold> thresholdDimension,
            ContainerVulnerabilityRepository vulnerabilityRepository)
        {
            _logger = logger;
            _eventPublisher = eventPublisher;
            _clusterDimension = clusterDimension;
            _thresholdDimension = thresholdDimension;
            _vulnerabilityRepository = vulnerabilityRepository;
        }
        
        [Function("VulnerabilityProcessor")]
        public async Task Run(
            [ServiceBusTrigger("security-events", "container-vulnerability-processor", Connection = "ServiceBusConnection")] 
            ServiceBusReceivedMessage message,
            FunctionContext context)
        {
            _logger.LogInformation("Processing vulnerability event: {MessageId}", message.MessageId);
            
            try
            {
                // Extract event type
                var eventType = message.ApplicationProperties.TryGetValue("EventType", out var eventTypeObj)
                    ? eventTypeObj?.ToString()
                    : null;
                    
                if (string.IsNullOrEmpty(eventType) || eventType != nameof(ContainerVulnerabilityEvent))
                {
                    _logger.LogWarning("Skipping message with unexpected event type: {EventType}", eventType);
                    return;
                }
                
                // Parse the event
                var json = Encoding.UTF8.GetString(message.Body);
                var vulnerabilityEvent = JsonSerializer.Deserialize<ContainerVulnerabilityEvent>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
                
                if (vulnerabilityEvent == null)
                {
                    _logger.LogError("Failed to deserialize ContainerVulnerabilityEvent");
                    return;
                }
                
                // Process the vulnerability
                await ProcessVulnerabilityEventAsync(vulnerabilityEvent);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing vulnerability event: {MessageId}", message.MessageId);
                throw;
            }
        }
        
        /// <summary>
        /// Process a container vulnerability event
        /// </summary>
        private async Task ProcessVulnerabilityEventAsync(ContainerVulnerabilityEvent vulnerabilityEvent)
        {
            try
            {
                // Check if we should create an incident based on severity and thresholds
                if (!ShouldCreateIncident(vulnerabilityEvent))
                {
                    _logger.LogInformation("Vulnerability {CveId} with severity {Severity} does not meet incident threshold, storing only",
                        vulnerabilityEvent.CveId, vulnerabilityEvent.Severity);
                    
                    // Store the vulnerability state
                    await StoreVulnerabilityStateAsync(vulnerabilityEvent);
                    return;
                }
                
                // Check if this vulnerability already exists for this container
                var existingVulnerability = await _vulnerabilityRepository.GetByCveAndContainerAsync(
                    vulnerabilityEvent.CveId, 
                    vulnerabilityEvent.ContainerName,
                    vulnerabilityEvent.ClusterId);
                
                if (existingVulnerability != null)
                {
                    _logger.LogInformation("Updating existing vulnerability state for {CveId} in {ContainerName}",
                        vulnerabilityEvent.CveId, vulnerabilityEvent.ContainerName);
                    
                    // Update the existing record
                    existingVulnerability.LastDetectedAt = DateTime.UtcNow;
                    existingVulnerability.ScanCount += 1;
                    
                    // Update if severity changed
                    if (existingVulnerability.Severity != vulnerabilityEvent.Severity.ToString())
                    {
                        existingVulnerability.Severity = vulnerabilityEvent.Severity.ToString();
                        existingVulnerability.CvssScore = vulnerabilityEvent.CvssScore;
                        
                        // Create an update notification if severity increased
                        if (IsSeverityIncrease(existingVulnerability.Severity, vulnerabilityEvent.Severity.ToString()))
                        {
                            await CreateSeverityChangeNotificationAsync(vulnerabilityEvent, existingVulnerability);
                        }
                    }
                    
                    // Update the state
                    await _vulnerabilityRepository.UpdateAsync(existingVulnerability);
                }
                else
                {
                    _logger.LogInformation("Creating new vulnerability state and incident for {CveId} in {ContainerName}",
                        vulnerabilityEvent.CveId, vulnerabilityEvent.ContainerName);
                    
                    // Store the vulnerability state
                    var state = await StoreVulnerabilityStateAsync(vulnerabilityEvent);
                    
                    // Create vulnerability notification event
                    await CreateVulnerabilityNotificationAsync(vulnerabilityEvent, state);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing vulnerability event for {CveId} in {ContainerName}",
                    vulnerabilityEvent.CveId, vulnerabilityEvent.ContainerName);
                throw;
            }
        }
        
        /// <summary>
        /// Store vulnerability state in the repository
        /// </summary>
        private async Task<ContainerVulnerabilityState> StoreVulnerabilityStateAsync(ContainerVulnerabilityEvent vulnerabilityEvent)
        {
            var state = new ContainerVulnerabilityState
            {
                CveId = vulnerabilityEvent.CveId,
                VulnerabilityName = vulnerabilityEvent.VulnerabilityName,
                CvssScore = vulnerabilityEvent.CvssScore,
                Severity = vulnerabilityEvent.Severity.ToString(),
                TenantId = vulnerabilityEvent.OwnerId,
                ClusterId = vulnerabilityEvent.ClusterId,
                Namespace = vulnerabilityEvent.Namespace,
                PodName = vulnerabilityEvent.PodName,
                ContainerName = vulnerabilityEvent.ContainerName,
                ImageName = vulnerabilityEvent.ImageName,
                ImageTag = vulnerabilityEvent.ImageTag,
                AffectedPackage = vulnerabilityEvent.AffectedPackage,
                InstalledVersion = vulnerabilityEvent.InstalledVersion,
                FixedVersion = vulnerabilityEvent.FixedVersion,
                IsFixable = vulnerabilityEvent.IsFixable,
                FirstDetectedAt = vulnerabilityEvent.FirstDetectedAt,
                LastDetectedAt = DateTime.UtcNow,
                ScanCount = 1,
                Status = "Active"
            };
            
            return await _vulnerabilityRepository.InsertAsync(state);
        }
        
        /// <summary>
        /// Create notification for a new vulnerability
        /// </summary>
        private async Task CreateVulnerabilityNotificationAsync(
            ContainerVulnerabilityEvent vulnerabilityEvent,
            ContainerVulnerabilityState state)
        {
            // Create notification event
            var notificationEvent = new VulnerabilityNotificationEvent
            {
                CveId = vulnerabilityEvent.CveId,
                VulnerabilityName = vulnerabilityEvent.VulnerabilityName,
                Severity = vulnerabilityEvent.Severity,
                OwnerId = vulnerabilityEvent.OwnerId,
                ResourceId = vulnerabilityEvent.ResourceId,
                ClusterId = vulnerabilityEvent.ClusterId,
                ContainerName = vulnerabilityEvent.ContainerName,
                ImageName = vulnerabilityEvent.ImageName,
                ImageTag = vulnerabilityEvent.ImageTag,
                CvssScore = vulnerabilityEvent.CvssScore,
                AffectedPackage = vulnerabilityEvent.AffectedPackage,
                InstalledVersion = vulnerabilityEvent.InstalledVersion,
                FixedVersion = vulnerabilityEvent.FixedVersion,
                IsFixable = vulnerabilityEvent.IsFixable,
                NotificationType = "NewVulnerability",
                VulnerabilityId = state.VulnerabilityId,
                CorrelationId = vulnerabilityEvent.EventId
            };
            
            // Add cluster information
            EnrichWithClusterInfo(notificationEvent, vulnerabilityEvent.ClusterId);
            
            // Publish the notification
            await _eventPublisher.PublishEventAsync(notificationEvent, topicName: "notifications");
            
            _logger.LogInformation("Published new vulnerability notification for {CveId} in {ContainerName}",
                vulnerabilityEvent.CveId, vulnerabilityEvent.ContainerName);
        }
        
        /// <summary>
        /// Create notification for a severity change
        /// </summary>
        private async Task CreateSeverityChangeNotificationAsync(
            ContainerVulnerabilityEvent vulnerabilityEvent,
            ContainerVulnerabilityState state)
        {
            // Create notification event
            var notificationEvent = new VulnerabilityNotificationEvent
            {
                CveId = vulnerabilityEvent.CveId,
                VulnerabilityName = vulnerabilityEvent.VulnerabilityName,
                Severity = vulnerabilityEvent.Severity,
                OwnerId = vulnerabilityEvent.OwnerId,
                ResourceId = vulnerabilityEvent.ResourceId,
                ClusterId = vulnerabilityEvent.ClusterId,
                ContainerName = vulnerabilityEvent.ContainerName,
                ImageName = vulnerabilityEvent.ImageName,
                ImageTag = vulnerabilityEvent.ImageTag,
                CvssScore = vulnerabilityEvent.CvssScore,
                AffectedPackage = vulnerabilityEvent.AffectedPackage,
                InstalledVersion = vulnerabilityEvent.InstalledVersion,
                FixedVersion = vulnerabilityEvent.FixedVersion,
                IsFixable = vulnerabilityEvent.IsFixable,
                NotificationType = "SeverityIncrease",
                PreviousSeverity = state.Severity,
                VulnerabilityId = state.VulnerabilityId,
                CorrelationId = vulnerabilityEvent.EventId
            };
            
            // Add cluster information
            EnrichWithClusterInfo(notificationEvent, vulnerabilityEvent.ClusterId);
            
            // Publish the notification
            await _eventPublisher.PublishEventAsync(notificationEvent, topicName: "notifications");
            
            _logger.LogInformation("Published severity change notification for {CveId} in {ContainerName}: {OldSeverity} -> {NewSeverity}",
                vulnerabilityEvent.CveId, vulnerabilityEvent.ContainerName, state.Severity, vulnerabilityEvent.Severity);
        }
        
        /// <summary>
        /// Determine if we should create an incident based on severity thresholds
        /// </summary>
        private bool ShouldCreateIncident(ContainerVulnerabilityEvent vulnerabilityEvent)
        {
            try
            {
                // Get threshold for this tenant
                var thresholds = _thresholdDimension.FindAsync(t => 
                    t.TenantId == vulnerabilityEvent.OwnerId).GetAwaiter().GetResult();
                
                var threshold = thresholds.Count > 0 
                    ? thresholds[0] 
                    : GetDefaultThreshold(vulnerabilityEvent.OwnerId);
                
                // Compare with threshold
                return vulnerabilityEvent.Severity >= threshold.MinimumSeverity;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error determining if incident should be created for {CveId}", 
                    vulnerabilityEvent.CveId);
                
                // Default to creating incident for Critical/High severity
                return vulnerabilityEvent.Severity >= SecuritySeverity.High;
            }
        }
        
        /// <summary>
        /// Get default threshold if not configured
        /// </summary>
        private VulnerabilityThreshold GetDefaultThreshold(string tenantId)
        {
            return new VulnerabilityThreshold
            {
                TenantId = tenantId,
                MinimumSeverity = SecuritySeverity.High,
                ShouldGroupIncidents = true
            };
        }
        
        /// <summary>
        /// Check if severity has increased
        /// </summary>
        private bool IsSeverityIncrease(string oldSeverity, string newSeverity)
        {
            if (!Enum.TryParse<SecuritySeverity>(oldSeverity, out var oldSev) ||
                !Enum.TryParse<SecuritySeverity>(newSeverity, out var newSev))
            {
                return false;
            }
            
            return (int)newSev > (int)oldSev;
        }
        
        /// <summary>
        /// Enrich notification with cluster information
        /// </summary>
        private void EnrichWithClusterInfo(VulnerabilityNotificationEvent notification, string clusterId)
        {
            try
            {
                var clusters = _clusterDimension.FindAsync(c => c.ClusterId == clusterId).GetAwaiter().GetResult();
                
                if (clusters.Count > 0)
                {
                    var cluster = clusters[0];
                    notification.ClusterName = cluster.Name;
                    notification.Location = cluster.Location;
                    notification.ResourceGroupName = cluster.ResourceGroupName;
                    
                    if (cluster.IsAksCluster)
                    {
                        notification.Metadata["AksCluster"] = "true";
                    }
                    
                    if (cluster.Labels != null)
                    {
                        foreach (var label in cluster.Labels)
                        {
                            if (label.Key.StartsWith("kubernetes.io") || label.Key.StartsWith("k8s.io"))
                                continue;
                                
                            notification.Metadata[$"Label.{label.Key}"] = label.Value;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error enriching notification with cluster info for cluster {ClusterId}", clusterId);
            }
        }
    }
    
    /// <summary>
    /// Vulnerability notification event
    /// </summary>
    public class VulnerabilityNotificationEvent : SecurityEvent
    {
        /// <summary>
        /// CVE identifier
        /// </summary>
        public string CveId { get; set; }
        
        /// <summary>
        /// Vulnerability name
        /// </summary>
        public string VulnerabilityName { get; set; }
        
        /// <summary>
        /// CVSS score (0.0-10.0)
        /// </summary>
        public float CvssScore { get; set; }
        
        /// <summary>
        /// Cluster ID
        /// </summary>
        public string ClusterId { get; set; }
        
        /// <summary>
        /// Cluster name
        /// </summary>
        public string ClusterName { get; set; }
        
        /// <summary>
        /// Azure region
        /// </summary>
        public string Location { get; set; }
        
        /// <summary>
        /// Resource group name
        /// </summary>
        public string ResourceGroupName { get; set; }
        
        /// <summary>
        /// Container name
        /// </summary>
        public string ContainerName { get; set; }
        
        /// <summary>
        /// Image name
        /// </summary>
        public string ImageName { get; set; }
        
        /// <summary>
        /// Image tag
        /// </summary>
        public string ImageTag { get; set; }
        
        /// <summary>
        /// Affected package
        /// </summary>
        public string AffectedPackage { get; set; }
        
        /// <summary>
        /// Installed version
        /// </summary>
        public string InstalledVersion { get; set; }
        
        /// <summary>
        /// Fixed version
        /// </summary>
        public string FixedVersion { get; set; }
        
        /// <summary>
        /// Is fixable
        /// </summary>
        public bool IsFixable { get; set; }
        
        /// <summary>
        /// Notification type
        /// </summary>
        public string NotificationType { get; set; }
        
        /// <summary>
        /// Previous severity (for severity change notifications)
        /// </summary>
        public string PreviousSeverity { get; set; }
        
        /// <summary>
        /// Internal vulnerability ID
        /// </summary>
        public string VulnerabilityId { get; set; }
    }
    
    /// <summary>
    /// Vulnerability threshold configuration
    /// </summary>
    public class VulnerabilityThreshold
    {
        /// <summary>
        /// Tenant ID
        /// </summary>
        public string TenantId { get; set; }
        
        /// <summary>
        /// Minimum severity to create incidents
        /// </summary>
        public SecuritySeverity MinimumSeverity { get; set; }
        
        /// <summary>
        /// Whether to group vulnerabilities by image
        /// </summary>
        public bool ShouldGroupIncidents { get; set; }
    }
}
