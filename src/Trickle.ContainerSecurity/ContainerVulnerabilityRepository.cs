using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Dapper;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Trickle.Common.State;

namespace Trickle.ContainerSecurity.Processors.CSharp
{
    /// <summary>
    /// Repository for storing container vulnerability states
    /// </summary>
    public class ContainerVulnerabilityRepository : PostgresRepository<ContainerVulnerabilityState, string>
    {
        public ContainerVulnerabilityRepository(
            ILogger<ContainerVulnerabilityRepository> logger,
            IOptions<StateManagementOptions> options)
            : base("container_vulnerabilities", "vulnerability_id", "tenant_id", logger, options)
        {
        }
        
        /// <summary>
        /// Insert new vulnerability state
        /// </summary>
        public override async Task<ContainerVulnerabilityState> InsertAsync(
            ContainerVulnerabilityState entity, 
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(entity.VulnerabilityId))
            {
                entity.VulnerabilityId = Guid.NewGuid().ToString();
            }
            
            return await _retryPolicy.ExecuteAsync(async () =>
            {
                using var conn = await CreateConnectionAsync(cancellationToken);
                
                var sql = @$"
                    INSERT INTO {_options.SchemaName}.{_tableName}
                    (
                        vulnerability_id, cve_id, vulnerability_name, cvss_score, severity,
                        tenant_id, cluster_id, namespace, pod_name, container_name,
                        image_name, image_tag, affected_package, installed_version, fixed_version,
                        is_fixable, first_detected_at, last_detected_at, scan_count, status,
                        incident_id, remediation_status, remediated_at, metadata
                    )
                    VALUES
                    (
                        @VulnerabilityId, @CveId, @VulnerabilityName, @CvssScore, @Severity,
                        @TenantId, @ClusterId, @Namespace, @PodName, @ContainerName,
                        @ImageName, @ImageTag, @AffectedPackage, @InstalledVersion, @FixedVersion,
                        @IsFixable, @FirstDetectedAt, @LastDetectedAt, @ScanCount, @Status,
                        @IncidentId, @RemediationStatus, @RemediatedAt, @Metadata
                    )
                    RETURNING *";
                    
                return await conn.QuerySingleAsync<ContainerVulnerabilityState>(sql, entity);
            });
        }
        
        /// <summary>
        /// Update existing vulnerability state
        /// </summary>
        public override async Task<ContainerVulnerabilityState> UpdateAsync(
            ContainerVulnerabilityState entity, 
            CancellationToken cancellationToken = default)
        {
            return await _retryPolicy.ExecuteAsync(async () =>
            {
                using var conn = await CreateConnectionAsync(cancellationToken);
                
                var sql = @$"
                    UPDATE {_options.SchemaName}.{_tableName}
                    SET
                        cve_id = @CveId,
                        vulnerability_name = @VulnerabilityName,
                        cvss_score = @CvssScore,
                        severity = @Severity,
                        tenant_id = @TenantId,
                        cluster_id = @ClusterId,
                        namespace = @Namespace,
                        pod_name = @PodName,
                        container_name = @ContainerName,
                        image_name = @ImageName,
                        image_tag = @ImageTag,
                        affected_package = @AffectedPackage,
                        installed_version = @InstalledVersion,
                        fixed_version = @FixedVersion,
                        is_fixable = @IsFixable,
                        first_detected_at = @FirstDetectedAt,
                        last_detected_at = @LastDetectedAt,
                        scan_count = @ScanCount,
                        status = @Status,
                        incident_id = @IncidentId,
                        remediation_status = @RemediationStatus,
                        remediated_at = @RemediatedAt,
                        metadata = @Metadata
                    WHERE
                        vulnerability_id = @VulnerabilityId
                    RETURNING *";
                    
                return await conn.QuerySingleAsync<ContainerVulnerabilityState>(sql, entity);
            });
        }
        
        /// <summary>
        /// Get vulnerability by CVE ID and container details
        /// </summary>
        public async Task<ContainerVulnerabilityState> GetByCveAndContainerAsync(
            string cveId, 
            string containerName, 
            string clusterId,
            string status = "Active",
            CancellationToken cancellationToken = default)
        {
            return await _retryPolicy.ExecuteAsync(async () =>
            {
                using var conn = await CreateConnectionAsync(cancellationToken);
                
                var sql = @$"
                    SELECT * FROM {_options.SchemaName}.{_tableName}
                    WHERE cve_id = @CveId
                    AND container_name = @ContainerName
                    AND cluster_id = @ClusterId
                    AND (@Status IS NULL OR status = @Status)
                    ORDER BY last_detected_at DESC
                    LIMIT 1";
                    
                return await conn.QuerySingleOrDefaultAsync<ContainerVulnerabilityState>(sql, new 
                {
                    CveId = cveId,
                    ContainerName = containerName,
                    ClusterId = clusterId,
                    Status = status
                });
            });
        }
        
        /// <summary>
        /// Get vulnerabilities by image
        /// </summary>
        public async Task<IReadOnlyList<ContainerVulnerabilityState>> GetByImageAsync(
            string imageName,
            string imageTag = null,
            string status = "Active",
            CancellationToken cancellationToken = default)
        {
            return await _retryPolicy.ExecuteAsync(async () =>
            {
                using var conn = await CreateConnectionAsync(cancellationToken);
                
                var sql = @$"
                    SELECT * FROM {_options.SchemaName}.{_tableName}
                    WHERE image_name = @ImageName
                    AND (@ImageTag IS NULL OR image_tag = @ImageTag)
                    AND (@Status IS NULL OR status = @Status)
                    ORDER BY cvss_score DESC, last_detected_at DESC";
                    
                var results = await conn.QueryAsync<ContainerVulnerabilityState>(sql, new 
                {
                    ImageName = imageName,
                    ImageTag = imageTag,
                    Status = status
                });
                
                return results.AsList();
            });
        }
        
        /// <summary>
        /// Get vulnerabilities by cluster
        /// </summary>
        public async Task<IReadOnlyList<ContainerVulnerabilityState>> GetByClusterAsync(
            string clusterId,
            string status = "Active",
            CancellationToken cancellationToken = default)
        {
            return await _retryPolicy.ExecuteAsync(async () =>
            {
                using var conn = await CreateConnectionAsync(cancellationToken);
                
                var sql = @$"
                    SELECT * FROM {_options.SchemaName}.{_tableName}
                    WHERE cluster_id = @ClusterId
                    AND (@Status IS NULL OR status = @Status)
                    ORDER BY cvss_score DESC, last_detected_at DESC";
                    
                var results = await conn.QueryAsync<ContainerVulnerabilityState>(sql, new 
                {
                    ClusterId = clusterId,
                    Status = status
                });
                
                return results.AsList();
            });
        }
        
        /// <summary>
        /// Mark a vulnerability as remediated
        /// </summary>
        public async Task<ContainerVulnerabilityState> MarkAsRemediatedAsync(
            string vulnerabilityId,
            string remediationStatus,
            string remediationDetails = null,
            CancellationToken cancellationToken = default)
        {
            return await _retryPolicy.ExecuteAsync(async () =>
            {
                using var conn = await CreateConnectionAsync(cancellationToken);
                
                var sql = @$"
                    UPDATE {_options.SchemaName}.{_tableName}
                    SET
                        status = 'Remediated',
                        remediation_status = @RemediationStatus,
                        metadata = COALESCE(metadata, '') || ' ' || @RemediationDetails,
                        remediated_at = @RemediatedAt
                    WHERE
                        vulnerability_id = @VulnerabilityId
                    RETURNING *";
                    
                return await conn.QuerySingleAsync<ContainerVulnerabilityState>(sql, new
                {
                    VulnerabilityId = vulnerabilityId,
                    RemediationStatus = remediationStatus,
                    RemediationDetails = remediationDetails,
                    RemediatedAt = DateTime.UtcNow
                });
            });
        }
    }
    
    /// <summary>
    /// Container vulnerability state
    /// </summary>
    public class ContainerVulnerabilityState
    {
        /// <summary>
        /// Internal vulnerability ID
        /// </summary>
        public string VulnerabilityId { get; set; }
        
        /// <summary>
        /// CVE identifier
        /// </summary>
        public string CveId { get; set; }
        
        /// <summary>
        /// Vulnerability name
        /// </summary>
        public string VulnerabilityName { get; set; }
        
        /// <summary>
        /// CVSS score (0.0-10.0)
        /// </summary>
        public float CvssScore { get; set; }
        
        /// <summary>
        /// Severity level
        /// </summary>
        public string Severity { get; set; }
        
        /// <summary>
        /// Tenant ID
        /// </summary>
        public string TenantId { get; set; }
        
        /// <summary>
        /// Cluster ID
        /// </summary>
        public string ClusterId { get; set; }
        
        /// <summary>
        /// Kubernetes namespace
        /// </summary>
        public string Namespace { get; set; }
        
        /// <summary>
        /// Pod name
        /// </summary>
        public string PodName { get; set; }
        
        /// <summary>
        /// Container name
        /// </summary>
        public string ContainerName { get; set; }
        
        /// <summary>
        /// Container image name
        /// </summary>
        public string ImageName { get; set; }
        
        /// <summary>
        /// Container image tag
        /// </summary>
        public string ImageTag { get; set; }
        
        /// <summary>
        /// Affected package
        /// </summary>
        public string AffectedPackage { get; set; }
        
        /// <summary>
        /// Installed version
        /// </summary>
        public string InstalledVersion { get; set; }
        
        /// <summary>
        /// Fixed version
        /// </summary>
        public string FixedVersion { get; set; }
        
        /// <summary>
        /// Whether the vulnerability is fixable
        /// </summary>
        public bool IsFixable { get; set; }
        
        /// <summary>
        /// When first detected
        /// </summary>
        public DateTime FirstDetectedAt { get; set; }
        
        /// <summary>
        /// When last detected
        /// </summary>
        public DateTime LastDetectedAt { get; set; }
        
        /// <summary>
        /// Number of scans that detected this
        /// </summary>
        public int ScanCount { get; set; }
        
        /// <summary>
        /// Status (Active, Remediated, Suppressed)
        /// </summary>
        public string Status { get; set; }
        
        /// <summary>
        /// Associated incident ID
        /// </summary>
        public string IncidentId { get; set; }
        
        /// <summary>
        /// Remediation status
        /// </summary>
        public string RemediationStatus { get; set; }
        
        /// <summary>
        /// When remediated
        /// </summary>
        public DateTime? RemediatedAt { get; set; }
        
        /// <summary>
        /// Additional metadata
        /// </summary>
        public string Metadata { get; set; }
    }
}
